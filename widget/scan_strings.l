%{
/*
 *  $id$
 *
 *  (c) Till Straumann 1998 (strauman@sun6hft.ee.tu-berlin.de)
 *
 *  $Log: scan_strings.l,v $
 *  Revision 1.9  2000/10/02 21:26:07  cvs
 *   - activated the lex compatibility hacks
 *
 *  Revision 1.8  2000/06/20 02:10:56  till
 *   - older versions of flex have no yy_flush_buffer
 *
 *  Revision 1.7  2000/05/19 08:19:05  cvs
 *   - removed DependTarget3 from Imakefile again
 *   - added a release string and some checks
 *   - removed %option stdinit from scan_strings.l (not ANSI C)
 *
 *  Revision 1.6  1999/10/18 22:37:57  cvs
 *   - Imakefile supports building a (static) library now.
 *   - all (resource etc.) strings go to strDefs.c if SEPARATE_STRINGS is defined.
 *
 *  Revision 1.5  1999/02/05 12:45:56  till
 *   - minor, mainly cosmetic changes to scan_strings (removed trailing context)
 *   - TextField.h was empty in the last release :-)
 *
 *  Revision 1.4  1999/02/05 12:37:08  till
 *   - cplusplus / function prototypes support
 *   - added blinker, autoBlink, Commit (to includes also)
 *   - added Backup / Restore (to includes also)
 *   - updated the doc (in TextField.h)
 *   - minor changes to scan_strings.l
 *
 *  Revision 1.3  1998/04/19 11:00:26  till
 *  started cvs logging
 *
 *
 */
#ifndef YY_FLUSH_BUFFER
#define YY_FLUSH_BUFFER \
	fprintf(stderr,"warning: flex version has no yy_flush_buffer()\n")
#endif
#include <string.h>
#include <stdio.h>
	int name=0, class=0, type=0;
	int first=0;
	FILE *namef,*classf,*typef;
	char *prefix;
	char *warn_mess[]={
	 "/* THIS FILE WAS AUTOMATICALLY GENERATED BY SCAN_STRINGS */",
	 "/************************* DO NOT EDIT *******************/",
	(char*)0
	}; 
#if	NeedFunctionPrototypes
	void usage(char *name)
#else
	void usage(name)
	char *name;
#endif
	{
	fprintf(stderr,"usage: %s <prefix> [file names...]\n",name);
	fprintf(stderr,"converts stdin or <file>'s lines with format\n");
	fprintf(stderr,"##DOSCAN##Xt{N|C|R}<string>\n");
	fprintf(stderr,"to an include file on stdout (or `file'.h) defining\n");
	fprintf(stderr,"three external variables:\n");
	fprintf(stderr,"  extern char <prefix>ResStrings[],\n");
	fprintf(stderr,"  extern char <prefix>ClStrings[],\n");
	fprintf(stderr,"  extern char <prefix>TypeStrings[].\n");
	fprintf(stderr,"Three source files containing the strings\n");
	fprintf(stderr,"are also generated. They are called\n");
	fprintf(stderr,"  <prefix>_res_c\n");
	fprintf(stderr,"  <prefix>_class_c\n");
	fprintf(stderr,"  <prefix>_type_c\n");
	}
#if	NeedFunctionPrototypes
	void w_print(FILE * /*feil*/)
#else
	void w_print(feil)
	FILE *feil;
#endif
	{
	int i;
	for (i=0; warn_mess[i]; i++)
	 fprintf(feil,"%s\n",warn_mess[i]);
	}
%}
	/* NAME	[[:alnum:]]* */
NAME	[a-zA-Z_0-9]*
%s ANFANG MARKE
%%
<ANFANG>^##DOSCAN##	BEGIN(MARKE);
^##DOSCAN## 	{
		w_print(yyout);
		fprintf(yyout,"\n#ifdef __STDC__\n");
		fprintf(yyout,"extern const char	%sResStrings[];\n",prefix);
		fprintf(yyout,"extern const char	%sClStrings[];\n",prefix);
		fprintf(yyout,"extern const char	%sTypeStrings[];\n",prefix);
		fprintf(yyout,"#else\n");
		fprintf(yyout,"extern char	%sResStrings[];\n",prefix);
		fprintf(yyout,"extern char	%sClStrings[];\n",prefix);
		fprintf(yyout,"extern char	%sTypeStrings[];\n",prefix);
		fprintf(yyout,"#endif\n\n");
		BEGIN(MARKE);
		}
<MARKE>XtN{NAME} {
		fprintf(yyout,"#ifndef %s\n",yytext);
		fprintf(yyout,"#define %s ((char *)(&%sResStrings[%i]))\n",
			yytext, prefix, name);
		fprintf(yyout,"#endif");
		fprintf(namef,"%s\\0\\\n",yytext+3);
		/* strip XtN, add final \0 */
		name+=yyleng-2;
		BEGIN(ANFANG);
		}
<MARKE>XtC{NAME} {
		fprintf(yyout,"#ifndef %s\n",yytext);
		fprintf(yyout,"#define %s ((char *)(&%sClStrings[%i]))\n",
			yytext, prefix, class);
		fprintf(yyout,"#endif");
		fprintf(classf,"%s\\0\\\n",yytext+3);
		/* strip XtN, add final \0 */
		class+=yyleng-2;
		BEGIN(ANFANG);
		}
<MARKE>XtR{NAME}	{
		fprintf(yyout,"#ifndef %s\n",yytext);
		fprintf(yyout,"#define %s ((char *)(&%sTypeStrings[%i]))\n",
			yytext, prefix, type);
		fprintf(yyout,"#endif");
		fprintf(typef,"%s\\0\\\n",yytext+3);
		/* strip XtN, add final \0 */
		type+=yyleng-2;
		BEGIN(ANFANG);
		}
<MARKE>.|\n	fprintf(yyout,"#SCANERROR");BEGIN(ANFANG);
		/* <<EOF>>	{ YY_FLUSH_BUFFER; BEGIN(INITIAL); yyterminate(); } */
%%
#if	NeedFunctionPrototypes
	int main(int,char**)
#else
	int main(argc,argv)
	int argc;
	char *argv[];
#endif
	{
	 char *namefs="_res_c";
	 char *classfs="_class_c";
	 char *typefs="_type_c";
	 char buf[BUFSIZ];
	 int  nfiles;

	 /* Initialize yyin/yyout; with newer glibc versions, the
	  *   %option stdinit
	  * doesnt work anymore...
	  */
	 yyin=stdin; yyout=stdout;

	 if (argc<2) { usage(argv[0]); exit(1); }
	 prefix=argv[1];
	 sprintf(buf,"%s%s",prefix,namefs);
	 if (argc<3) {
        nfiles = 1;
	 } else {
		fclose(stdout);
		fclose(stdin);
		yyout = NULL;
		yyin  = NULL;
		nfiles = argc-2;
	 }
	 namef=fopen(buf,"w");
	 fprintf(namef,"#ifdef __STDC__\n#define Const const\n#else\n#define Const /**/\n#endif\n\n");
	 fprintf(namef,
		"#ifndef %s\n#define %s\n",buf,buf);
	 w_print(namef);
	 fprintf(namef,
		"\nConst char %sResStrings[]={\"\\\n",prefix);
	 sprintf(buf,"%s%s",prefix,classfs);
	 classf=fopen(buf,"w");
	 fprintf(classf,"#ifdef __STDC__\n#define Const const\n#else\n#define Const /**/\n#endif\n\n");
	 fprintf(classf,
		"#ifndef %s\n#define %s\n",buf,buf);
	 w_print(classf);
	 fprintf(classf,
		"Const char %sClStrings[]={\"\\\n",
		prefix);
	 sprintf(buf,"%s%s",prefix,typefs);
	 typef=fopen(buf,"w");
	 fprintf(typef,"#ifdef __STDC__\n#define Const const\n#else\n#define Const /**/\n#endif\n\n");
	 fprintf(typef,
		"#ifndef %s\n#define %s\n",buf,buf);
	 w_print(typef);
	 fprintf(typef,
		"Const char %sTypeStrings[]={\"\\\n",
		prefix);
	 for (; nfiles>0; nfiles--) {
		if (!yyout) {
			char *chpt;
			strcpy(buf,argv[argc-nfiles]);
			yyin=fopen(buf,"r");
			if ( (chpt=strchr(buf,'.')) ) {
				strcpy(chpt+1,"h");
			} else {
				strcat(buf,".h");
			}
			yyout=fopen(buf,"w+");
		}
	 	w_print(yyout);
	 	yylex();
		BEGIN(0);
		fclose(yyin);
		fclose(yyout);
		yyout=NULL;
		yyin=NULL;
	 }
	 fprintf(namef,"\"};\n#endif\n");
	 fprintf(classf,"\"};\n#endif\n");
	 fprintf(typef,"\"};\n#endif\n");
	 exit(0);
	}
/* NOTE: LEX compatibility may be achieved by
 *
 *       - eliminating the <<EOF>> rule
 *       - adding BEGIN(0); statement after yylex();
 *       - replacing [:alnum:] class by [a-zA-Z0-9]
 */
